<!DOCTYPE html>
<!--
写一个html程序，使用three.js和cannon.js模拟建筑爆破，在页面上添加暂停/继续和重置按钮。使用orbitcontrol.js控制视角旋转。添加天空球，使用pbr渲染。在可折叠菜单调节建筑层数、爆破强度、太阳高度角和太阳旋转。

注：本程序已完成bug修复，但实际视觉表现比较差。
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>建筑爆破模拟器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* 控制面板 */
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .control-panel.collapsed {
            width: 60px;
            padding: 20px 10px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            cursor: pointer;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            transition: opacity 0.3s;
        }

        .control-panel.collapsed .panel-title {
            opacity: 0;
        }

        .toggle-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .control-panel.collapsed .toggle-btn {
            transform: rotate(180deg);
        }

        .control-group {
            margin-bottom: 20px;
            opacity: 1;
            transition: opacity 0.3s;
            max-height: 500px;
            overflow: hidden;
        }

        .control-panel.collapsed .control-group {
            opacity: 0;
            max-height: 0;
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ccc;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #66BB6A;
        }

        .value-display {
            min-width: 40px;
            text-align: right;
            font-size: 14px;
            color: #4CAF50;
        }

        /* 按钮样式 */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #66BB6A;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #42A5F5;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #ef5350;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
        }

        /* 信息提示 */
        .info-toast {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .info-toast.show {
            opacity: 1;
        }

        /* 加载动画 */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading">加载中...</div>
    </div>

    <div class="control-panel" id="controlPanel">
        <div class="panel-header" onclick="togglePanel()">
            <h2 class="panel-title">控制面板</h2>
            <button class="toggle-btn">◀</button>
        </div>

        <div class="control-group">
            <div class="control-group">
                <label class="control-label">建筑层数</label>
                <div class="slider-container">
                    <input type="range" id="floorCount" min="10" max="48" value="24" step="1">
                    <span class="value-display" id="floorCountValue">24</span>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">爆破强度</label>
                <div class="slider-container">
                    <input type="range" id="explosionPower" min="50" max="1000" value="200" step="10">
                    <span class="value-display" id="explosionPowerValue">200</span>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">太阳高度角</label>
                <div class="slider-container">
                    <input type="range" id="sunHeight" min="0" max="90" value="45" step="1">
                    <span class="value-display" id="sunHeightValue">45°</span>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">太阳旋转</label>
                <div class="slider-container">
                    <input type="range" id="sunRotation" min="0" max="360" value="0" step="1">
                    <span class="value-display" id="sunRotationValue">0°</span>
                </div>
            </div>
        </div>

        <div class="button-group">
            <button class="btn btn-primary" id="playPauseBtn">暂停</button>
            <button class="btn btn-danger" id="resetBtn">重置</button>
            <button class="btn btn-secondary" id="explodeBtn">爆破</button>
        </div>
    </div>

    <div class="info-toast" id="infoToast"></div>

    <!-- 引入必要的库 -->
    <script src="../../libs/three.min.js"></script>
    <script src="../../libs/cannon.min.js"></script>
    <script src="../../libs/OrbitControls.js"></script>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let world;
        let building = [];
        let ground;
        let sun, ambientLight;
        let skybox;
        let isPaused = false;
        let isExploded = false;

        // 初始化场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            // 创建相机
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                3000
            );
            camera.position.set(100, 60, 100);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;

            // 创建物理世界
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // 创建天空盒
            createSkybox();

            // 创建光照
            createLights();

            // 创建地面
            createGround();

            // 创建建筑
            createBuilding();

            // 隐藏加载提示
            document.querySelector('.loading').style.display = 'none';

            // 开始动画循环
            animate();
        }

        // 创建天空盒
        function createSkybox() {
            const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                map: createSkyTexture(),
                side: THREE.BackSide
            });
            skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);
        }

        // 创建天空纹理
        function createSkyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 创建渐变天空
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.5, '#98D8E8');
            gradient.addColorStop(1, '#F0E68C');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);

            // 添加云朵
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 200 + 50;
                const size = Math.random() * 50 + 30;
                drawCloud(ctx, x, y, size);
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // 绘制云朵
        function drawCloud(ctx, x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y - size * 0.1, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x - size * 0.4, y - size * 0.1, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x + size * 0.2, y + size * 0.1, size * 0.3, 0, Math.PI * 2);
            ctx.arc(x - size * 0.2, y + size * 0.1, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // 创建光照
        function createLights() {
            // 环境光
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 太阳光
            sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -100;
            sun.shadow.camera.right = 100;
            sun.shadow.camera.top = 100;
            sun.shadow.camera.bottom = -100;
            sun.shadow.camera.near = 0.1;
            sun.shadow.camera.far = 200;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);
        }

        // 创建地面
        function createGround() {
            // Three.js 地面
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Cannon.js 地面
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.add(groundBody);
        }

        // 创建建筑
        function createBuilding() {
            clearBuilding();
            
            const floorCount = parseInt(document.getElementById('floorCount').value);
            const floorHeight = 3;
            const buildingWidth = 20;
            const buildingDepth = 20;
            
            for (let floor = 0; floor < floorCount; floor++) {
                // 创建楼层
                const floorGeometry = new THREE.BoxGeometry(buildingWidth, floorHeight, buildingDepth);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.6, 0.1, 0.5 + floor * 0.02),
                    roughness: 0.7,
                    metalness: 0.3
                });
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                floorMesh.position.y = floor * floorHeight + floorHeight / 2;
                floorMesh.castShadow = true;
                floorMesh.receiveShadow = true;
                scene.add(floorMesh);

                // 创建物理体
                const floorShape = new CANNON.Box(new CANNON.Vec3(buildingWidth / 2, floorHeight / 2, buildingDepth / 2));
                const floorBody = new CANNON.Body({
                    mass: 1000,
                    shape: floorShape,
                    position: new CANNON.Vec3(0, floor * floorHeight + floorHeight / 2, 0)
                });
                world.add(floorBody);

                building.push({ mesh: floorMesh, body: floorBody });
            }

            showToast('建筑已创建');
        }

        // 清除建筑
        function clearBuilding() {
            building.forEach(item => {
                scene.remove(item.mesh);
                world.remove(item.body);
            });
            building = [];
            isExploded = false;
        }

        // 爆破建筑
        function explodeBuilding() {
            if (isExploded) {
                showToast('建筑已经爆破过了');
                return;
            }

            const explosionPower = parseFloat(document.getElementById('explosionPower').value);
            const explosionCenter = new CANNON.Vec3(0, building.length * 1.5, 0);

            building.forEach((item, index) => {
                // 计算方向向量
                const direction = new CANNON.Vec3();
                direction.copy(item.body.position);
                direction.vsub(explosionCenter, direction);
                direction.normalize();
                
                // 计算距离
                const distance = item.body.position.distanceTo(explosionCenter);
                const force = explosionPower * 1000 / (distance + 1);
                
                // 施加冲击力
                const impulse = direction.scale(force);
                item.body.applyImpulse(impulse, item.body.position);
                
                // 添加旋转 - 设置角速度
                const angularVelocity = new CANNON.Vec3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                item.body.angularVelocity.copy(angularVelocity);
                
                // 在偏移点施加额外的力来产生更复杂的旋转
                const offset = new CANNON.Vec3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
                const forcePoint = new CANNON.Vec3();
                forcePoint.copy(item.body.position);
                forcePoint.vadd(offset, forcePoint);
                
                const rotationalForce = direction.scale(force * 0.3);
                item.body.applyForce(rotationalForce, forcePoint);
            });

            isExploded = true;
            showToast('爆破！');
        }

        // 重置场景
        function resetScene() {
            clearBuilding();
            createBuilding();
            isPaused = false;
            document.getElementById('playPauseBtn').textContent = '暂停';
            showToast('场景已重置');
        }

        // 暂停/继续
        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('playPauseBtn').textContent = isPaused ? '继续' : '暂停';
            showToast(isPaused ? '已暂停' : '已继续');
        }

        // 更新太阳位置
        function updateSun() {
            const height = parseFloat(document.getElementById('sunHeight').value);
            const rotation = parseFloat(document.getElementById('sunRotation').value);
            
            const radHeight = height * Math.PI / 180;
            const radRotation = rotation * Math.PI / 180;
            
            const distance = 150;
            sun.position.x = distance * Math.cos(radHeight) * Math.cos(radRotation);
            sun.position.y = distance * Math.sin(radHeight);
            sun.position.z = distance * Math.cos(radHeight) * Math.sin(radRotation);
            
            sun.intensity = 0.5 + height / 180;
        }

        // 显示提示信息
        function showToast(message) {
            const toast = document.getElementById('infoToast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // 切换控制面板
        function togglePanel() {
            const panel = document.getElementById('controlPanel');
            panel.classList.toggle('collapsed');
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                world.step(1/60);
                
                // 同步物理和渲染
                building.forEach(item => {
                    item.mesh.position.copy(item.body.position);
                    item.mesh.quaternion.copy(item.body.quaternion);
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 事件监听器
        document.getElementById('floorCount').addEventListener('input', (e) => {
            document.getElementById('floorCountValue').textContent = e.target.value;
            if (!isExploded) {
                createBuilding();
            }
        });

        document.getElementById('explosionPower').addEventListener('input', (e) => {
            document.getElementById('explosionPowerValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('sunHeight').addEventListener('input', (e) => {
            document.getElementById('sunHeightValue').textContent = e.target.value + '°';
            updateSun();
        });

        document.getElementById('sunRotation').addEventListener('input', (e) => {
            document.getElementById('sunRotationValue').textContent = e.target.value + '°';
            updateSun();
        });

        document.getElementById('playPauseBtn').addEventListener('click', togglePause);
        document.getElementById('resetBtn').addEventListener('click', resetScene);
        document.getElementById('explodeBtn').addEventListener('click', explodeBuilding);

        // 初始化
        init();
    </script>
</body>
</html>