<!DOCTYPE html>
<!--
创建随机山地地形并创建水面，摄像机面向水平方向，按WASD键控制摄像机移动，根据与摄像机距离确定生成和删除地形的范围。创建天空球，使用pbr渲染。

注：本期主要为概念验证，未添加更多功能，虽然需要手动修改参数但确定了连续地形生成的可行性。鼠标控制和水面生成有一定问题。
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>随机山地地形与水面 - PBR渲染</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">
        使用 WASD 键移动摄像机 | 鼠标控制视角<br>
        当前位置: <span id="position">X:0, Z:0</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 场景设置
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // 摄像机初始位置
        camera.position.set(0, 20, 50);
        camera.lookAt(0, 0, 0);

        // PBR材质参数
        const terrainMaterial = new THREE.MeshStandardMaterial({
            color: 0x006400,
            roughness: 0.8,
            metalness: 0.1,
        });

        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.0,
            metalness: 0.9,
            transparent: true,
            opacity: 0.8,
            envMapIntensity: 1.0
        });

        // 地形生成参数
        const TERRAIN_SIZE = 256;
        const TERRAIN_SEGMENTS = 256;
        const WATER_LEVEL = 15;
        const RENDER_DISTANCE = 768;
        const TERRAIN_HEIGHT = 30;

        // 存储地形块
        const terrainChunks = new Map();
        
        // 创建天空球
        const skyGeometry = new THREE.SphereGeometry(5000, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // 创建环境光和方向光
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 200;
        scene.add(directionalLight);

        // 创建水面
        const waterGeometry = new THREE.PlaneGeometry(500, 500, 64, 64);
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = WATER_LEVEL;
        water.receiveShadow = true;
        scene.add(water);

        // 添加水面波浪动画
        function animateWater() {
            const time = Date.now() * 0.001;
            const vertices = water.geometry.attributes.position;
            
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const z = vertices.getZ(i);
                const waveHeight = Math.sin(x * 0.05 + time) * Math.cos(z * 0.05 + time) * 0.5;
                vertices.setY(i, waveHeight);
            }
            
            vertices.needsUpdate = true;
            water.geometry.computeVertexNormals();
        }

        // 生成地形高度图
        function generateHeightMap(width, height, offsetX = 0, offsetZ = 0) {
            const heightMap = new Float32Array(width * height);
            const scale = 0.03;
            
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const x = (j + offsetX) * scale;
                    const z = (i + offsetZ) * scale;
                    
                    // 多层噪声生成地形
                    let height = 0;
                    height += Math.sin(x * 0.5) * Math.cos(z * 0.5) * 15;
                    height += Math.sin(x * 2) * Math.cos(z * 2) * 5;
                    height += Math.sin(x * 4) * Math.cos(z * 4) * 2.5;
                    
                    // 添加随机细节
                    height += (Math.random() - 0.5) * 2;
                    
                    heightMap[i * width + j] = Math.max(-WATER_LEVEL + 1, height);
                }
            }
            
            return heightMap;
        }

        // 创建地形块
        function createTerrainChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (terrainChunks.has(key)) return;

            const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS - 1, TERRAIN_SEGMENTS - 1);
            geometry.rotateX(-Math.PI / 2);

            const heightMap = generateHeightMap(TERRAIN_SEGMENTS, TERRAIN_SEGMENTS, chunkX * TERRAIN_SIZE, chunkZ * TERRAIN_SIZE);
            
            const vertices = geometry.attributes.position;
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i) + chunkX * TERRAIN_SIZE;
                const z = vertices.getZ(i) + chunkZ * TERRAIN_SIZE;
                
                const heightIndex = Math.floor((i / TERRAIN_SEGMENTS)) * TERRAIN_SEGMENTS + (i % TERRAIN_SEGMENTS);
                const height = heightMap[heightIndex];
                
                vertices.setY(i, height);
            }

            geometry.computeVertexNormals();
            
            const terrain = new THREE.Mesh(geometry, terrainMaterial);
            terrain.position.x = chunkX * TERRAIN_SIZE;
            terrain.position.z = chunkZ * TERRAIN_SIZE;
            terrain.castShadow = true;
            terrain.receiveShadow = true;
            
            scene.add(terrain);
            terrainChunks.set(key, terrain);
        }

        // 移除地形块
        function removeTerrainChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            const terrain = terrainChunks.get(key);
            if (terrain) {
                scene.remove(terrain);
                terrain.geometry.dispose();
                terrainChunks.delete(key);
            }
        }

        // 更新可见地形
        function updateVisibleTerrain() {
            const camChunkX = Math.floor(camera.position.x / TERRAIN_SIZE);
            const camChunkZ = Math.floor(camera.position.z / TERRAIN_SIZE);
            
            // 计算需要加载的区块
            const chunksToLoad = [];
            for (let x = -2; x <= 2; x++) {
                for (let z = -2; z <= 2; z++) {
                    const chunkX = camChunkX + x;
                    const chunkZ = camChunkZ + z;
                    const distance = Math.sqrt(
                        Math.pow(camera.position.x - (chunkX * TERRAIN_SIZE + TERRAIN_SIZE/2), 2) +
                        Math.pow(camera.position.z - (chunkZ * TERRAIN_SIZE + TERRAIN_SIZE/2), 2)
                    );
                    
                    if (distance < RENDER_DISTANCE) {
                        chunksToLoad.push([chunkX, chunkZ]);
                    }
                }
            }
            
            // 加载新地形
            chunksToLoad.forEach(([x, z]) => createTerrainChunk(x, z));
            
            // 移除超出范围的地形
            terrainChunks.forEach((terrain, key) => {
                const [chunkX, chunkZ] = key.split(',').map(Number);
                const distance = Math.sqrt(
                    Math.pow(camera.position.x - (chunkX * TERRAIN_SIZE + TERRAIN_SIZE/2), 2) +
                    Math.pow(camera.position.z - (chunkZ * TERRAIN_SIZE + TERRAIN_SIZE/2), 2)
                );
                
                if (distance > RENDER_DISTANCE + TERRAIN_SIZE) {
                    removeTerrainChunk(chunkX, chunkZ);
                }
            });
        }

        // 键盘控制
        const keys = {};
        const moveSpeed = 0.5;
        const cameraHeight = 30;

        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // 鼠标控制
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        document.addEventListener('mousedown', () => isMouseDown = true);
        document.addEventListener('mouseup', () => isMouseDown = false);
        document.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = (e.clientY / window.innerHeight) * 2 - 1;
            }
        });

        // 更新摄像机位置
        function updateCamera() {
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (keys['w']) camera.position.add(forward.multiplyScalar(moveSpeed));
            if (keys['s']) camera.position.add(forward.multiplyScalar(-moveSpeed));
            if (keys['a']) camera.position.add(right.multiplyScalar(-moveSpeed));
            if (keys['d']) camera.position.add(right.multiplyScalar(moveSpeed));

            // 限制摄像机高度
            camera.position.y = cameraHeight;

            // 更新显示信息
            document.getElementById('position').textContent = 
                `X:${Math.round(camera.position.x)}, Z:${Math.round(camera.position.z)}`;
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始化地形
        updateVisibleTerrain();

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            updateCamera();
            updateVisibleTerrain();
            animateWater();
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>