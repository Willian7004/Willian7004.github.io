<!DOCTYPE html>
<!--
写一个html程序，使用three.js和cannon.js。鼠标或触屏按下时从场景上方一定高度的屏幕的相应位置连续创建随机颜色的物体。在随机菜单中选择物体类型（可选正方体/球体/圆柱体/圆锥体和四棱锥）和创建速度，可设置场景平面尺寸和创建的物体尺寸。模拟物体之间以及物体与场景的碰撞效果。创建天空球，使用pbr渲染，在可折叠菜单设置太阳高度角和太阳水平方向。

注：在网页版进行过一次修改，但出现四棱锥无法生成的问题。
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D物理模拟器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
            z-index: 100;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
        }

        .toggle-icon {
            font-size: 20px;
            transition: transform 0.3s ease;
        }

        .panel-content {
            max-height: 600px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .panel-content.collapsed {
            max-height: 0;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .control-group select,
        .control-group input {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            background: transparent;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        .value-display {
            font-size: 12px;
            color: #ccc;
            margin-top: 2px;
        }

        .switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #4CAF50;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            z-index: 100;
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            z-index: 100;
        }

        .clear-button {
            width: 100%;
            padding: 10px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }

        .clear-button:hover {
            background: #d32f2f;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="control-panel">
        <div class="panel-header" onclick="togglePanel()">
            <div class="panel-title">控制面板</div>
            <div class="toggle-icon" id="toggle-icon">▼</div>
        </div>
        <div class="panel-content" id="panel-content">
            <div class="control-group">
                <label>物体类型</label>
                <select id="objectType">
                    <option value="box">正方体</option>
                    <option value="sphere">球体</option>
                    <option value="cylinder">圆柱体</option>
                    <option value="cone">圆锥体</option>
                    <option value="pyramid">四棱锥</option>
                </select>
            </div>

            <div class="control-group">
                <label>创建速度 (个/秒)</label>
                <input type="range" id="creationSpeed" min="1" max="20" value="5">
                <div class="value-display" id="speedDisplay">5 个/秒</div>
            </div>

            <div class="control-group">
                <label>场景平面尺寸</label>
                <input type="range" id="planeSize" min="10" max="100" value="50">
                <div class="value-display" id="planeSizeDisplay">50 米</div>
            </div>

            <div class="control-group">
                <label>物体尺寸</label>
                <input type="range" id="objectSize" min="0.5" max="3" step="0.1" value="1">
                <div class="value-display" id="objectSizeDisplay">1.0 米</div>
            </div>

            <div class="control-group">
                <label>太阳高度角</label>
                <input type="range" id="sunHeight" min="0" max="90" value="45">
                <div class="value-display" id="sunHeightDisplay">45°</div>
            </div>

            <div class="control-group">
                <label>太阳水平方向</label>
                <input type="range" id="sunAzimuth" min="0" max="360" value="0">
                <div class="value-display" id="sunAzimuthDisplay">0°</div>
            </div>

            <div class="control-group">
                <div class="switch-container">
                    <label>相机自动旋转</label>
                    <label class="switch">
                        <input type="checkbox" id="cameraRotation">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <button class="clear-button" onclick="clearObjects()">清除所有物体</button>
        </div>
    </div>

    <div class="instructions">
        <strong>操作说明：</strong><br>
        • 按住鼠标或触摸屏幕创建物体<br>
        • 物体会从上方掉落并发生碰撞<br>
        • 使用控制面板调整参数
    </div>

    <div class="stats">
        <div>物体数量: <span id="objectCount">0</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>

    <script src="../../libs/three.min.js"></script>
    <script src="../../libs/cannon.min.js"></script>
    <script>
        // 全局变量
        let scene, camera, renderer, world;
        let objects = [];
        let isCreating = false;
        let lastCreationTime = 0;
        let clock = new THREE.Clock();
        let frameCount = 0;
        let lastTime = 0;
        let cameraAutoRotate = false;

        // 控制变量
        let objectType = 'box';
        let creationSpeed = 5;
        let planeSize = 50;
        let objectSize = 1;
        let sunHeight = 45;
        let sunAzimuth = 0;

        // 初始化场景
        function init() {
            // 创建Three.js场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 创建Cannon.js世界
            world = new CANNON.World();
            world.gravity.set(0, -98, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.defaultContactMaterial.contactEquationStiffness = 1e8;
            world.defaultContactMaterial.contactEquationRelaxation = 3;

            // 创建地面
            createGround();
            
            // 创建天空球
            createSkybox();
            
            // 创建光照
            createLights();
            
            // 设置事件监听
            setupEventListeners();
            
            // 开始渲染循环
            animate();
        }

        // 创建地面
        function createGround() {
            // Three.js地面
            const groundGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Cannon.js地面 - 增加厚度以防止穿透
            const groundShape = new CANNON.Box(new CANNON.Vec3(planeSize/2, 1, planeSize/2));
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                position: new CANNON.Vec3(0, -1, 0)
            });
            world.add(groundBody);
        }

        // 创建天空球
        function createSkybox() {
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);
        }

        // 创建光照
        function createLights() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // 方向光（太阳）
            updateSunlight();
        }

        // 更新太阳光照
        function updateSunlight() {
            // 移除现有的方向光
            const existingLights = scene.children.filter(child => child.type === 'DirectionalLight');
            existingLights.forEach(light => scene.remove(light));

            // 计算太阳位置
            const heightRad = (sunHeight * Math.PI) / 180;
            const azimuthRad = (sunAzimuth * Math.PI) / 180;
            
            const x = Math.cos(heightRad) * Math.sin(azimuthRad);
            const y = Math.sin(heightRad);
            const z = Math.cos(heightRad) * Math.cos(azimuthRad);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(x * 100, y * 100, z * 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            
            scene.add(sunLight);
        }

        // 创建物体
        function createObject(x, z) {
            const color = new THREE.Color(Math.random(), Math.random(), Math.random());
            let geometry, shape, mesh, body;

            switch(objectType) {
                case 'box':
                    geometry = new THREE.BoxGeometry(objectSize, objectSize, objectSize);
                    shape = new CANNON.Box(new CANNON.Vec3(objectSize/2, objectSize/2, objectSize/2));
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(objectSize/2, 16, 16);
                    shape = new CANNON.Sphere(objectSize/2);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(objectSize/2, objectSize/2, objectSize, 16);
                    shape = new CANNON.Cylinder(objectSize/2, objectSize/2, objectSize, 16);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(objectSize/2, objectSize, 16);
                    // 使用更精确的圆锥体碰撞形状
                    shape = new CANNON.Cylinder(0.01, objectSize/2, objectSize, 16);
                    break;
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(objectSize/2, objectSize, 4);
                    // 对于四棱锥，使用复合形状来更好地模拟
                    const pyramidHeight = objectSize;
                    const pyramidBase = objectSize/2;
                    
                    // 创建复合形状：底部是一个薄盒子，上面是一个金字塔形状
                    const bottomBox = new CANNON.Box(new CANNON.Vec3(pyramidBase*0.7, 0.1, pyramidBase*0.7));
                    const topCone = new CANNON.Cylinder(0.01, pyramidBase*0.7, pyramidHeight*0.8, 4);
                    
                    shape = new CANNON.Compound();
                    shape.addChild(bottomBox, new CANNON.Vec3(0, -pyramidHeight/2 + 0.1, 0));
                    shape.addChild(topCone, new CANNON.Vec3(0, 0.1, 0));
                    break;
            }

            // 创建材质
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });

            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 15, z); // 稍微提高初始高度
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // 创建物理体
            body = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(x, 15, z),
                linearDamping: 0.01, // 添加阻尼以减少穿透
                angularDamping: 0.01
            });

            // 为圆锥体和四棱锥添加额外的约束
            if (objectType === 'cone' || objectType === 'pyramid') {
                body.sleepSpeedLimit = 0.1;
                body.sleepTimeLimit = 0.1;
            }

            world.add(body);

            objects.push({ mesh, body });
            updateObjectCount();
        }

        // 设置事件监听
        function setupEventListeners() {
            // 鼠标事件
            renderer.domElement.addEventListener('mousedown', (e) => {
                isCreating = true;
                createObjectAtPosition(e.clientX, e.clientY);
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isCreating = false;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isCreating) {
                    const currentTime = Date.now();
                    if (currentTime - lastCreationTime > 1000 / creationSpeed) {
                        createObjectAtPosition(e.clientX, e.clientY);
                        lastCreationTime = currentTime;
                    }
                }
            });

            // 触摸事件
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isCreating = true;
                const touch = e.touches[0];
                createObjectAtPosition(touch.clientX, touch.clientY);
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                isCreating = false;
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isCreating) {
                    const currentTime = Date.now();
                    if (currentTime - lastCreationTime > 1000 / creationSpeed) {
                        const touch = e.touches[0];
                        createObjectAtPosition(touch.clientX, touch.clientY);
                        lastCreationTime = currentTime;
                    }
                }
            });

            // 窗口大小调整
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 控制面板事件
            setupControlPanelEvents();
        }

        // 在指定位置创建物体
        function createObjectAtPosition(clientX, clientY) {
            const mouse = new THREE.Vector2();
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // 与地面相交
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectPoint);

            createObject(intersectPoint.x, intersectPoint.z);
        }

        // 设置控制面板事件
        function setupControlPanelEvents() {
            document.getElementById('objectType').addEventListener('change', (e) => {
                objectType = e.target.value;
            });

            document.getElementById('creationSpeed').addEventListener('input', (e) => {
                creationSpeed = parseInt(e.target.value);
                document.getElementById('speedDisplay').textContent = creationSpeed + ' 个/秒';
            });

            document.getElementById('planeSize').addEventListener('input', (e) => {
                planeSize = parseInt(e.target.value);
                document.getElementById('planeSizeDisplay').textContent = planeSize + ' 米';
                updateGroundSize();
            });

            document.getElementById('objectSize').addEventListener('input', (e) => {
                objectSize = parseFloat(e.target.value);
                document.getElementById('objectSizeDisplay').textContent = objectSize.toFixed(1) + ' 米';
            });

            document.getElementById('sunHeight').addEventListener('input', (e) => {
                sunHeight = parseInt(e.target.value);
                document.getElementById('sunHeightDisplay').textContent = sunHeight + '°';
                updateSunlight();
            });

            document.getElementById('sunAzimuth').addEventListener('input', (e) => {
                sunAzimuth = parseInt(e.target.value);
                document.getElementById('sunAzimuthDisplay').textContent = sunAzimuth + '°';
                updateSunlight();
            });

            document.getElementById('cameraRotation').addEventListener('change', (e) => {
                cameraAutoRotate = e.target.checked;
            });
        }

        // 清除所有物体
        function clearObjects() {
            objects.forEach(obj => {
                scene.remove(obj.mesh);
                world.remove(obj.body);
            });
            objects = [];
            updateObjectCount();
        }

        // 更新地面尺寸
        function updateGroundSize() {
            // 移除旧地面
            const oldGround = scene.children.find(child => child.geometry && child.geometry.type === 'PlaneGeometry');
            if (oldGround) scene.remove(oldGround);

            const oldGroundBody = world.bodies.find(body => body.shapes[0].type === CANNON.Shape.types.BOX);
            if (oldGroundBody) world.remove(oldGroundBody);

            // 创建新地面
            createGround();
        }

        // 更新物体数量显示
        function updateObjectCount() {
            document.getElementById('objectCount').textContent = objects.length;
        }

        // 切换面板
        function togglePanel() {
            const content = document.getElementById('panel-content');
            const icon = document.getElementById('toggle-icon');
            
            content.classList.toggle('collapsed');
            icon.style.transform = content.classList.contains('collapsed') ? 'rotate(-90deg)' : 'rotate(0deg)';
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 更新物理世界 - 使用更小的时间步长以提高精度
            world.step(1/120);

            // 同步Three.js和Cannon.js
            objects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
                
                // 防止物体穿透地面
                if (obj.body.position.y < objectSize/2) {
                    obj.body.position.y = objectSize/2;
                    obj.body.velocity.y = Math.abs(obj.body.velocity.y) * 0.3; // 反弹并减少能量
                }
            });

            // 更新FPS
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            // 相机围绕场景旋转（可开关）
            if (cameraAutoRotate) {
                const time = Date.now() * 0.0005;
                camera.position.x = Math.cos(time) * 40;
                camera.position.z = Math.sin(time) * 40;
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        // 启动应用
        init();
    </script>
</body>
</html>