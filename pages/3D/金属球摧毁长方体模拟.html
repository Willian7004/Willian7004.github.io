<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D物理模拟 - 正方体堆叠与球体投掷</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            width: 320px;
            max-height: 50vh;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .control-panel.collapsed {
            width: 50px;
            height: 50px;
            overflow: hidden;
        }

        .panel-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
            user-select: none;
        }

        .panel-header h3 {
            font-size: 16px;
            font-weight: 600;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 20px;
        }

        .control-panel.collapsed .collapse-icon {
            transform: rotate(180deg);
        }

        .panel-content {
            padding: 20px;
        }

        .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .control-group h4 {
            color: #333;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-item {
            margin-bottom: 12px;
        }

        .control-item label {
            display: block;
            color: #666;
            font-size: 13px;
            margin-bottom: 5px;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: background 0.2s;
        }

        .control-item input[type="range"]::-webkit-slider-thumb:hover {
            background: #764ba2;
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            background: #f5f5f5;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #333;
            margin-left: 8px;
        }

        .action-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
        }

        .trajectory-preview {
            position: absolute;
            pointer-events: none;
            opacity: 0.6;
        }

        /* 滚动条样式 */
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="control-panel" id="controlPanel">
        <div class="panel-header" onclick="togglePanel()">
            <h3>控制面板</h3>
            <span class="collapse-icon">▼</span>
        </div>
        <div class="panel-content">
            <div class="control-group">
                <h4>场景设置</h4>
                <div class="control-item">
                    <label>长方体长度 (X轴) <span class="value-display" id="lengthValue">8</span></label>
                    <input type="range" id="cubeLength" min="5" max="15" value="8" step="1">
                </div>
                <div class="control-item">
                    <label>长方体宽度 (Z轴) <span class="value-display" id="widthValue">8</span></label>
                    <input type="range" id="cubeWidth" min="5" max="15" value="8" step="1">
                </div>
                <div class="control-item">
                    <label>长方体高度 (Y轴) <span class="value-display" id="heightValue">5</span></label>
                    <input type="range" id="cubeHeight" min="3" max="10" value="5" step="1">
                </div>
                <div class="control-item">
                    <label>摄像机视野 <span class="value-display" id="fovValue">75°</span></label>
                    <input type="range" id="cameraFov" min="30" max="120" value="75" step="5">
                </div>
                <button class="action-button" onclick="regenerateCubes()">重新生成长方体</button>
            </div>

            <div class="control-group">
                <h4>球体设置</h4>
                <div class="control-item">
                    <label>球体密度 <span class="value-display" id="densityValue">5.0</span></label>
                    <input type="range" id="ballDensity" min="3" max="10" value="5" step="0.1">
                </div>
                <div class="control-item">
                    <label>球体大小倍数 <span class="value-display" id="sizeValue">2.0</span></label>
                    <input type="range" id="ballSize" min="1" max="5" value="2" step="0.1">
                </div>
                <div class="control-item">
                    <label>投出速度 <span class="value-display" id="speedValue">15</span></label>
                    <input type="range" id="throwSpeed" min="5" max="30" value="15" step="1">
                </div>
                <div class="control-item">
                    <label>重力大小 <span class="value-display" id="gravityValue">9.8</span></label>
                    <input type="range" id="gravity" min="1" max="20" value="9.8" step="0.2">
                </div>
            </div>

            <div class="control-group">
                <h4>光照设置</h4>
                <div class="control-item">
                    <label>太阳高度角 <span class="value-display" id="sunHeightValue">45°</span></label>
                    <input type="range" id="sunHeight" min="0" max="90" value="45" step="5">
                </div>
                <div class="control-item">
                    <label>太阳方向 <span class="value-display" id="sunDirectionValue">0°</span></label>
                    <input type="range" id="sunDirection" min="0" max="360" value="0" step="15">
                </div>
            </div>

            <div class="control-group">
                <button class="action-button" onclick="clearBalls()">清除所有球体</button>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div>按住鼠标左键或触摸屏幕预览轨迹</div>
        <div>松开投掷球体</div>
        <div>鼠标右键拖动旋转视角</div>
    </div>

    <script src="../../libs/three.min.js"></script>
    <script src="../../libs/cannon.min.js"></script>
    <script>
        // 全局变量
        let scene, camera, renderer;
        let world;
        let cubes = [];
        let balls = [];
        let ground;
        let trajectoryPreview = null;
        let isAiming = false;
        let aimStart = null;
        let aimEnd = null;
        let controls;

        // 配置参数
        const config = {
            cubeSize: 1,
            cubeLength: 8,
            cubeWidth: 8,
            cubeHeight: 5,
            ballDensity: 5.0,
            ballSizeMultiplier: 2.0,
            throwSpeed: 15,
            gravity: 9.8,
            sunHeight: 45,
            sunDirection: 0
        };

        // 初始化Three.js场景
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            // 相机
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(15, 15, 15);
            camera.lookAt(0, 5, 0);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 创建天空球
            createSkybox();

            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 添加方向光（太阳）
            updateSunLight();

            // 创建地面
            createGround();

            // 添加轨道控制
            addOrbitControls();
        }

        // 创建天空球
        function createSkybox() {
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                metalness: 0.0,
                roughness: 1.0,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);
        }

        // 更新太阳光照
        function updateSunLight() {
            // 移除旧的光源
            const oldLight = scene.getObjectByName('sunLight');
            if (oldLight) scene.remove(oldLight);

            // 计算太阳位置
            const heightRad = THREE.MathUtils.degToRad(config.sunHeight);
            const directionRad = THREE.MathUtils.degToRad(config.sunDirection);
            
            const x = Math.cos(heightRad) * Math.sin(directionRad);
            const y = Math.sin(heightRad);
            const z = Math.cos(heightRad) * Math.cos(directionRad);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(x * 100, y * 100, z * 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.name = 'sunLight';
            
            scene.add(sunLight);

            // 更新天空颜色
            const skyIntensity = Math.max(0.3, y);
            scene.fog.color.setHSL(0.55, 0.7, skyIntensity * 0.6);
            const skybox = scene.children.find(child => child.geometry instanceof THREE.SphereGeometry);
            if (skybox) {
                skybox.material.color.setHSL(0.55, 0.7, skyIntensity * 0.8);
            }
        }

        // 创建地面
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a7d44,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // 创建物理地面
            const groundShape = new CANNON.Box(new CANNON.Vec3(50, 0.1, 50));
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                position: new CANNON.Vec3(0, -0.1, 0)
            });
            world.add(groundBody);
        }

        // 生成长方体
        function generateCubes() {
            // 清除旧的立方体
            cubes.forEach(cube => {
                scene.remove(cube.mesh);
                world.remove(cube.body);
            });
            cubes = [];

            const startX = -(config.cubeLength - 1) * config.cubeSize / 2;
            const startZ = -(config.cubeWidth - 1) * config.cubeSize / 2;

            for (let x = 0; x < config.cubeLength; x++) {
                for (let z = 0; z < config.cubeWidth; z++) {
                    for (let y = 0; y < config.cubeHeight; y++) {
                        createCube(
                            startX + x * config.cubeSize,
                            y * config.cubeSize + config.cubeSize / 2,
                            startZ + z * config.cubeSize
                        );
                    }
                }
            }
        }

        // 创建单个立方体
        function createCube(x, y, z) {
            // 随机颜色
            const color = new THREE.Color(
                Math.random(),
                Math.random(),
                Math.random()
            );

            // Three.js立方体
            const geometry = new THREE.BoxGeometry(config.cubeSize, config.cubeSize, config.cubeSize);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js立方体
            const shape = new CANNON.Box(new CANNON.Vec3(config.cubeSize / 2, config.cubeSize / 2, config.cubeSize / 2));
            const body = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(x, y, z)
            });
            world.add(body);

            cubes.push({ mesh, body });
        }

        // 创建球体
        function createBall(position, velocity) {
            const radius = config.cubeSize * config.ballSizeMultiplier / 2;

            // Three.js球体
            const geometry = new THREE.SphereGeometry(radius, 32, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.5,
                metalness: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js球体
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({
                mass: config.ballDensity * (4/3 * Math.PI * radius * radius * radius),
                shape: shape,
                position: new CANNON.Vec3(position.x, position.y, position.z)
            });
            body.velocity.copy(velocity);
            world.add(body);

            balls.push({ mesh, body });
        }

        // 创建轨迹预览
        function createTrajectoryPreview(start, end) {
            if (trajectoryPreview) {
                scene.remove(trajectoryPreview);
            }

            const direction = new THREE.Vector3().subVectors(end, start);
            const velocity = direction.normalize().multiplyScalar(config.throwSpeed);

            // 计算抛物线点
            const points = [];
            const gravity = new THREE.Vector3(0, -config.gravity, 0);
            const timeStep = 0.1;
            let position = start.clone();
            let currentVelocity = velocity.clone();

            for (let i = 0; i < 50; i++) {
                points.push(position.clone());
                currentVelocity.add(gravity.clone().multiplyScalar(timeStep));
                position.add(currentVelocity.clone().multiplyScalar(timeStep));

                if (position.y < 0) break;
            }

            // 创建轨迹线
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xffff00,
                linewidth: 2,
                transparent: true,
                opacity: 0.6
            });
            trajectoryPreview = new THREE.Line(geometry, material);
            scene.add(trajectoryPreview);

            // 创建预览球体
            const previewGeometry = new THREE.SphereGeometry(config.cubeSize * config.ballSizeMultiplier / 2, 16, 8);
            const previewMaterial = new THREE.MeshBasicMaterial({
                color: 0x808080,
                transparent: true,
                opacity: 0.5
            });
            const previewMesh = new THREE.Mesh(previewGeometry, previewMaterial);
            previewMesh.position.copy(start);
            scene.add(previewMesh);
            trajectoryPreview.previewMesh = previewMesh;
        }

        // 更新轨迹预览
        function updateTrajectoryPreview(start, end) {
            if (!trajectoryPreview) return;
            
            trajectoryPreview.previewMesh.position.copy(start);
            
            const direction = new THREE.Vector3().subVectors(end, start);
            const velocity = direction.normalize().multiplyScalar(config.throwSpeed);

            const points = [];
            const gravity = new THREE.Vector3(0, -config.gravity, 0);
            const timeStep = 0.1;
            let position = start.clone();
            let currentVelocity = velocity.clone();

            for (let i = 0; i < 50; i++) {
                points.push(position.clone());
                currentVelocity.add(gravity.clone().multiplyScalar(timeStep));
                position.add(currentVelocity.clone().multiplyScalar(timeStep));

                if (position.y < 0) break;
            }

            trajectoryPreview.geometry.setFromPoints(points);
        }

        // 清除轨迹预览
        function clearTrajectoryPreview() {
            if (trajectoryPreview) {
                scene.remove(trajectoryPreview);
                if (trajectoryPreview.previewMesh) {
                    scene.remove(trajectoryPreview.previewMesh);
                }
                trajectoryPreview = null;
            }
        }

        // 添加轨道控制
        function addOrbitControls() {
            // 简单的轨道控制实现
            let isRotating = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 2) { // 右键
                    isRotating = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isRotating) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 5, 0);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isRotating = false;
            });

            // 触摸控制
            let touchStart = null;
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && touchStart) {
                    const deltaMove = {
                        x: e.touches[0].clientX - touchStart.x,
                        y: e.touches[0].clientY - touchStart.y
                    };

                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 5, 0);

                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                touchStart = null;
            });

            // 鼠标滚轮缩放
            renderer.domElement.addEventListener('wheel', (e) => {
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(5, 100);
            });
        }

        // 初始化Cannon.js世界
        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, -config.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 更新物理世界
            world.step(1/60);

            // 同步Three.js和Cannon.js
            cubes.forEach(cube => {
                cube.mesh.position.copy(cube.body.position);
                cube.mesh.quaternion.copy(cube.body.quaternion);
            });

            balls.forEach((ball, index) => {
                ball.mesh.position.copy(ball.body.position);
                ball.mesh.quaternion.copy(ball.body.quaternion);

                // 移除掉落的球体
                if (ball.body.position.y < -10) {
                    scene.remove(ball.mesh);
                    world.remove(ball.body);
                    balls.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        // 事件处理
        function setupEventListeners() {
            // 鼠标事件
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // 左键
                    isAiming = true;
                    const rect = renderer.domElement.getBoundingClientRect();
                    aimStart = new THREE.Vector3(
                        ((e.clientX - rect.left) / rect.width) * 2 - 1,
                        -((e.clientY - rect.top) / rect.height) * 2 + 1,
                        0.5
                    );
                    aimStart.unproject(camera);
                }
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isAiming) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    aimEnd = new THREE.Vector3(
                        ((e.clientX - rect.left) / rect.width) * 2 - 1,
                        -((e.clientY - rect.top) / rect.height) * 2 + 1,
                        0.5
                    );
                    aimEnd.unproject(camera);
                    createTrajectoryPreview(aimStart, aimEnd);
                }
            });

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (e.button === 0 && isAiming) { // 左键
                    isAiming = false;
                    if (aimStart && aimEnd) {
                        const direction = new THREE.Vector3().subVectors(aimEnd, aimStart);
                        const velocity = direction.normalize().multiplyScalar(config.throwSpeed);
                        createBall(aimStart, new CANNON.Vec3(velocity.x, velocity.y, velocity.z));
                    }
                    clearTrajectoryPreview();
                    aimStart = null;
                    aimEnd = null;
                }
            });

            // 触摸事件
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isAiming = true;
                    const rect = renderer.domElement.getBoundingClientRect();
                    const touch = e.touches[0];
                    aimStart = new THREE.Vector3(
                        ((touch.clientX - rect.left) / rect.width) * 2 - 1,
                        -((touch.clientY - rect.top) / rect.height) * 2 + 1,
                        0.5
                    );
                    aimStart.unproject(camera);
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (isAiming && e.touches.length === 1) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    const touch = e.touches[0];
                    aimEnd = new THREE.Vector3(
                        ((touch.clientX - rect.left) / rect.width) * 2 - 1,
                        -((touch.clientY - rect.top) / rect.height) * 2 + 1,
                        0.5
                    );
                    aimEnd.unproject(camera);
                    updateTrajectoryPreview(aimStart, aimEnd);
                }
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                if (isAiming) {
                    isAiming = false;
                    if (aimStart && aimEnd) {
                        const direction = new THREE.Vector3().subVectors(aimEnd, aimStart);
                        const velocity = direction.normalize().multiplyScalar(config.throwSpeed);
                        createBall(aimStart, new CANNON.Vec3(velocity.x, velocity.y, velocity.z));
                    }
                    clearTrajectoryPreview();
                    aimStart = null;
                    aimEnd = null;
                }
            });

            // 窗口大小调整
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // 控制面板功能
        function togglePanel() {
            const panel = document.getElementById('controlPanel');
            panel.classList.toggle('collapsed');
        }

        function regenerateCubes() {
            generateCubes();
        }

        function clearBalls() {
            balls.forEach(ball => {
                scene.remove(ball.mesh);
                world.remove(ball.body);
            });
            balls = [];
        }

        // 设置控件事件监听
        function setupControlListeners() {
            // 长方体尺寸
            document.getElementById('cubeLength').addEventListener('input', (e) => {
                config.cubeLength = parseInt(e.target.value);
                document.getElementById('lengthValue').textContent = config.cubeLength;
            });

            document.getElementById('cubeWidth').addEventListener('input', (e) => {
                config.cubeWidth = parseInt(e.target.value);
                document.getElementById('widthValue').textContent = config.cubeWidth;
            });

            document.getElementById('cubeHeight').addEventListener('input', (e) => {
                config.cubeHeight = parseInt(e.target.value);
                document.getElementById('heightValue').textContent = config.cubeHeight;
            });

            // 摄像机视野
            document.getElementById('cameraFov').addEventListener('input', (e) => {
                const fov = parseInt(e.target.value);
                camera.fov = fov;
                camera.updateProjectionMatrix();
                document.getElementById('fovValue').textContent = fov + '°';
            });

            // 球体设置
            document.getElementById('ballDensity').addEventListener('input', (e) => {
                config.ballDensity = parseFloat(e.target.value);
                document.getElementById('densityValue').textContent = config.ballDensity.toFixed(1);
            });

            document.getElementById('ballSize').addEventListener('input', (e) => {
                config.ballSizeMultiplier = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = config.ballSizeMultiplier.toFixed(1);
            });

            document.getElementById('throwSpeed').addEventListener('input', (e) => {
                config.throwSpeed = parseInt(e.target.value);
                document.getElementById('speedValue').textContent = config.throwSpeed;
            });

            document.getElementById('gravity').addEventListener('input', (e) => {
                config.gravity = parseFloat(e.target.value);
                world.gravity.set(0, -config.gravity, 0);
                document.getElementById('gravityValue').textContent = config.gravity.toFixed(1);
            });

            // 光照设置
            document.getElementById('sunHeight').addEventListener('input', (e) => {
                config.sunHeight = parseInt(e.target.value);
                document.getElementById('sunHeightValue').textContent = config.sunHeight + '°';
                updateSunLight();
            });

            document.getElementById('sunDirection').addEventListener('input', (e) => {
                config.sunDirection = parseInt(e.target.value);
                document.getElementById('sunDirectionValue').textContent = config.sunDirection + '°';
                updateSunLight();
            });
        }

        // 初始化
        function init() {
            // 先初始化物理世界
            initCannon();
            // 再初始化Three.js场景
            initThree();
            // 然后生成立方体
            generateCubes();
            // 最后设置事件监听
            setupEventListeners();
            setupControlListeners();
            animate();
        }

        // 启动应用
        init();
    </script>
</body>
</html>