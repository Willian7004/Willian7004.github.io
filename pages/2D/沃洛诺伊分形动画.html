<!DOCTYPE html>
<!--
创建html页面，生成沃罗诺依分形并创建分色，通过菜单调节参数。

注：本期首次使用Kimi K2，直接使用一轮对话实现，动画未要求添加，效果有一定问题且帧率低，不过基本功能满足要求。
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>沃罗诺依分形艺术</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 280px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #a0a0ff;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #6b73ff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #9d4edd;
            transform: scale(1.2);
        }

        .value-display {
            display: inline-block;
            color: #fff;
            font-weight: bold;
            margin-left: 10px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .color-scheme {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-btn.active {
            border-color: #fff;
            transform: scale(1.1);
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="control-panel">
        <h3 style="margin-bottom: 20px; text-align: center;">沃罗诺依分形控制</h3>
        
        <div class="control-group">
            <label>点数量: <span class="value-display" id="pointsValue">50</span></label>
            <input type="range" id="pointsSlider" min="10" max="200" value="50">
        </div>
        
        <div class="control-group">
            <label>迭代深度: <span class="value-display" id="depthValue">3</span></label>
            <input type="range" id="depthSlider" min="1" max="5" value="3">
        </div>
        
        <div class="control-group">
            <label>色彩强度: <span class="value-display" id="intensityValue">0.7</span></label>
            <input type="range" id="intensitySlider" min="0" max="1" step="0.1" value="0.7">
        </div>
        
        <div class="control-group">
            <label>动画速度: <span class="value-display" id="speedValue">0.5</span></label>
            <input type="range" id="speedSlider" min="0" max="2" step="0.1" value="0.5">
        </div>
        
        <div class="control-group">
            <label>配色方案:</label>
            <div class="color-scheme">
                <div class="color-btn active" data-scheme="cosmic" style="background: linear-gradient(45deg, #667eea 0%, #764ba2 100%)"></div>
                <div class="color-btn" data-scheme="fire" style="background: linear-gradient(45deg, #ff6b6b 0%, #ffa500 100%)"></div>
                <div class="color-btn" data-scheme="ocean" style="background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%)"></div>
                <div class="color-btn" data-scheme="forest" style="background: linear-gradient(45deg, #43e97b 0%, #38f9d7 100%)"></div>
            </div>
        </div>
        
        <button onclick="regenerate()">重新生成</button>
        <button onclick="toggleAnimation()">暂停/播放动画</button>
    </div>
    
    <div class="info">点击画布添加新点 | 右键移除最近点</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let config = {
            points: 50,
            depth: 3,
            intensity: 0.7,
            speed: 0.5,
            colorScheme: 'cosmic',
            animating: true,
            time: 0
        };
        
        let points = [];
        let colorSchemes = {
            cosmic: ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe'],
            fire: ['#ff6b6b', '#ffa500', '#ff4757', '#ff3838', '#ff9500'],
            ocean: ['#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#667eea'],
            forest: ['#43e97b', '#38f9d7', '#11998e', '#38ef7d', '#667eea']
        };
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            regenerate();
        }
        
        function generatePoints() {
            points = [];
            for (let i = 0; i < config.points; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: colorSchemes[config.colorScheme][i % colorSchemes[config.colorScheme].length]
                });
            }
        }
        
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }
        
        function getColor(distance, maxDistance, color) {
            const intensity = 1 - (distance / maxDistance) * config.intensity;
            const hue = parseInt(color.slice(1), 16);
            const r = (hue >> 16) & 255;
            const g = (hue >> 8) & 255;
            const b = hue & 255;
            
            return `rgba(${r}, ${g}, ${b}, ${intensity})`;
        }
        
        function drawVoronoi() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    let minDist = Infinity;
                    let secondMinDist = Infinity;
                    let closestPoint = null;
                    
                    for (const point of points) {
                        const dist = distance({ x, y }, point);
                        if (dist < minDist) {
                            secondMinDist = minDist;
                            minDist = dist;
                            closestPoint = point;
                        } else if (dist < secondMinDist) {
                            secondMinDist = dist;
                        }
                    }
                    
                    let value = 0;
                    for (let i = 0; i < config.depth; i++) {
                        const wave = Math.sin(minDist * 0.01 + config.time * config.speed + i * Math.PI / config.depth);
                        value += wave * (1 - i / config.depth);
                    }
                    
                    const index = (y * canvas.width + x) * 4;
                    const color = closestPoint.color;
                    
                    const hue = parseInt(color.slice(1), 16);
                    const r = (hue >> 16) & 255;
                    const g = (hue >> 8) & 255;
                    const b = hue & 255;
                    
                    data[index] = r * (0.5 + value * 0.5);
                    data[index + 1] = g * (0.5 + value * 0.5);
                    data[index + 2] = b * (0.5 + value * 0.5);
                    data[index + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function animate() {
            if (config.animating) {
                config.time += 0.01;
                
                points.forEach(point => {
                    point.x += point.vx * config.speed;
                    point.y += point.vy * config.speed;
                    
                    if (point.x < 0 || point.x > canvas.width) point.vx *= -1;
                    if (point.y < 0 || point.y > canvas.height) point.vy *= -1;
                });
                
                drawVoronoi();
            }
            requestAnimationFrame(animate);
        }
        
        function regenerate() {
            generatePoints();
            drawVoronoi();
        }
        
        function toggleAnimation() {
            config.animating = !config.animating;
        }
        
        // 事件监听
        document.getElementById('pointsSlider').addEventListener('input', (e) => {
            config.points = parseInt(e.target.value);
            document.getElementById('pointsValue').textContent = config.points;
            regenerate();
        });
        
        document.getElementById('depthSlider').addEventListener('input', (e) => {
            config.depth = parseInt(e.target.value);
            document.getElementById('depthValue').textContent = config.depth;
        });
        
        document.getElementById('intensitySlider').addEventListener('input', (e) => {
            config.intensity = parseFloat(e.target.value);
            document.getElementById('intensityValue').textContent = config.intensity;
        });
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            config.speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = config.speed;
        });
        
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                config.colorScheme = e.target.dataset.scheme;
                regenerate();
            });
        });
        
        canvas.addEventListener('click', (e) => {
            points.push({
                x: e.clientX,
                y: e.clientY,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                color: colorSchemes[config.colorScheme][Math.floor(Math.random() * colorSchemes[config.colorScheme].length)]
            });
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (points.length > 0) {
                points.pop();
                drawVoronoi();
            }
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        // 初始化
        resizeCanvas();
        animate();
    </script>
</body>
</html>