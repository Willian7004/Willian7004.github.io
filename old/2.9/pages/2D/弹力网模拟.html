<!DOCTYPE html>
<!--
写一个html程序，使用2d形式。在页面上创建一个弹力网，固定在画布左右两端，在可折叠菜单调节弹力网固定点高度（按照占页面高度的比例调节）、弹力网长度（按照占页面宽度的比例调节，最小值和默认值为1，长度更大时模拟下垂效果）和弹力网硬度。在弹力网上方创建随机颜色的小球，在可折叠菜单调整小球数量、大小以及重力大小。模拟小球与其它小球、弹力网和画布边缘的弹性碰撞，增加合适的边距以防小球穿过弹力网。

本程序使用Kimi K2编写时没有实现回弹功能，经过多次检查才确定这一问题。修改后能正常运行，调节了一些参数。
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弹力网物理模拟</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        #menu {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            min-width: 200px;
            transition: all 0.3s ease;
        }
        
        #menu.collapsed {
            max-height: 40px;
            overflow: hidden;
        }
        
        #menu h3 {
            margin: 0 0 10px 0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #menu h3::after {
            content: '▼';
            transition: transform 0.3s;
        }
        
        #menu.collapsed h3::after {
            transform: rotate(-90deg);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group span {
            font-size: 11px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="menu">
        <h3 onclick="toggleMenu()">控制面板</h3>
        
        <div class="control-group">
            <label>弹力网固定点高度: <span id="heightValue">0.5</span></label>
            <input type="range" id="netHeight" min="0.1" max="0.9" step="0.05" value="0.5">
        </div>
        
        <div class="control-group">
            <label>弹力网长度: <span id="lengthValue">1.0</span></label>
            <input type="range" id="netLength" min="1" max="1.5" step="0.1" value="1">
        </div>
        
        <div class="control-group">
            <label>弹力网硬度: <span id="stiffnessValue">0.9</span></label>
            <input type="range" id="netStiffness" min="0.1" max="1" step="0.05" value="0.9">
        </div>
        
        <div class="control-group">
            <label>小球数量: <span id="ballCountValue">20</span></label>
            <input type="range" id="ballCount" min="10" max="60" step="1" value="20">
        </div>
        
        <div class="control-group">
            <label>小球大小: <span id="ballSizeValue">20</span></label>
            <input type="range" id="ballSize" min="10" max="60" step="1" value="20">
        </div>
        
        <div class="control-group">
            <label>重力大小: <span id="gravityValue">0.2</span></label>
            <input type="range" id="gravity" min="0" max="0.6" step="0.05" value="0.2">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let netHeight = 0.5;
        let netLength = 1;
        let netStiffness = 0.9;
        let ballCount = 20;
        let ballRadius = 20;
        let gravity = 0.15;
        
        const balls = [];
        const net = {
            points: [],
            segments: 60,
            damping: 0.99
        };
        
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = 0;
                this.radius = ballRadius;
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
                this.mass = this.radius;
            }
            
            update() {
                this.vy += gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // 边界碰撞
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.vx *= -0.8;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.vy *= -0.8;
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                }
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            checkCollision(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.radius + other.radius) {
                    const angle = Math.atan2(dy, dx);
                    const sin = Math.sin(angle);
                    const cos = Math.cos(angle);
                    
                    // 旋转坐标系
                    const vx1 = this.vx * cos + this.vy * sin;
                    const vy1 = this.vy * cos - this.vx * sin;
                    const vx2 = other.vx * cos + other.vy * sin;
                    const vy2 = other.vy * cos - other.vx * sin;
                    
                    // 弹性碰撞
                    const finalVx1 = ((this.mass - other.mass) * vx1 + 2 * other.mass * vx2) / (this.mass + other.mass);
                    const finalVx2 = ((other.mass - this.mass) * vx2 + 2 * this.mass * vx1) / (this.mass + other.mass);
                    
                    // 旋转回原坐标系
                    this.vx = finalVx1 * cos - vy1 * sin;
                    this.vy = vy1 * cos + finalVx1 * sin;
                    other.vx = finalVx2 * cos - vy2 * sin;
                    other.vy = vy2 * cos + finalVx2 * sin;
                    
                    // 分离重叠的小球
                    const overlap = this.radius + other.radius - distance;
                    this.x += (overlap / 2) * cos;
                    this.y += (overlap / 2) * sin;
                    other.x -= (overlap / 2) * cos;
                    other.y -= (overlap / 2) * sin;
                }
            }
        }
        
        class NetPoint {
            constructor(x, y, fixed = false) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.fixed = fixed;
            }
            
            update() {
                if (!this.fixed) {
                    const vx = (this.x - this.oldX) * net.damping;
                    const vy = (this.y - this.oldY) * net.damping;
                    
                    this.oldX = this.x;
                    this.oldY = this.y;
                    
                    this.x += vx;
                    this.y += vy;
                    this.y += gravity * 2;
                }
            }
        }
        
        function initNet() {
            net.points = [];
            const startY = canvas.height * netHeight;
            const netWidth = canvas.width * netLength;
            const startX = (canvas.width - netWidth) / 2;
            const endX = startX + netWidth;
            const segmentWidth = netWidth / net.segments;
            
            for (let i = 0; i <= net.segments; i++) {
                const x = startX + i * segmentWidth;
                const y = startY + Math.sin(i / net.segments * Math.PI) * 50 * (netLength - 1);
                net.points.push(new NetPoint(x, y, i === 0 || i === net.segments));
            }
        }
        
        function updateNet() {
            // 更新网点的位置
            for (let point of net.points) {
                point.update();
            }
            
            // 约束网点间的距离
            for (let i = 0; i < 20; i++) {
                for (let j = 1; j < net.points.length; j++) {
                    const p1 = net.points[j - 1];
                    const p2 = net.points[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const restLength = (canvas.width * netLength) / net.segments;
                    const difference = restLength - distance;
                    const percent = difference / distance / 2 * netStiffness;
                    const offsetX = dx * percent;
                    const offsetY = dy * percent;
                    
                    if (!p1.fixed) {
                        p1.x -= offsetX;
                        p1.y -= offsetY;
                    }
                    if (!p2.fixed) {
                        p2.x += offsetX;
                        p2.y += offsetY;
                    }
                }
            }
        }
        
        function drawNet() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 1; i < net.points.length; i++) {
                const p1 = net.points[i - 1];
                const p2 = net.points[i];
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();
            
            // 绘制网点
            ctx.fillStyle = '#666';
            for (let point of net.points) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function checkNetCollision(ball) {
    for (let i = 1; i < net.points.length; i++) {
        const p1 = net.points[i - 1];
        const p2 = net.points[i];

        // 1. 计算小球到线段的最短距离及最近点
        const dx   = p2.x - p1.x;
        const dy   = p2.y - p1.y;
        const seg2 = dx * dx + dy * dy;
        const t = Math.max(0, Math.min(1, ((ball.x - p1.x) * dx + (ball.y - p1.y) * dy) / seg2));
        const cx = p1.x + t * dx;
        const cy = p1.y + t * dy;

        const distX = ball.x - cx;
        const distY = ball.y - cy;
        const dist  = Math.sqrt(distX * distX + distY * distY);

        if (dist < ball.radius + 5) {   // 5 = 网线半厚度
            const nx = distX / dist;      // 法向量
            const ny = distY / dist;

            // 2. 小球相对网线的接近速度（只算法向分量）
            const vBallN = ball.vx * nx + ball.vy * ny;

            // 3. 如果小球正在远离网线，不处理
            if (vBallN > 0) continue;

            // 4. 计算反弹冲量大小（可调倍数 k 控制弹力）
            const k = 1.15 * netStiffness;     // 越大弹力越强
            const impulse = -vBallN * (1 + k);

            // 5. 给小球附加向上的反冲速度
            ball.vx += impulse * nx;
            ball.vy += impulse * ny;

            // 6. 让最近的两段网点也获得反冲，带动网线回弹
            const share = impulse * 0.3;      // 网点质量越大，此值可再调小
            if (!p1.fixed) {
                p1.x -= nx * share;
                p1.y -= ny * share;
            }
            if (!p2.fixed) {
                p2.x -= nx * share;
                p2.y -= ny * share;
            }

            // 7. 防止小球穿网：沿法线推出
            const overlap = ball.radius + 5 - dist;
            ball.x += nx * overlap;
            ball.y += ny * overlap;
        }
    }
}
        
        function initBalls() {
            balls.length = 0;
            for (let i = 0; i < ballCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.3;
                balls.push(new Ball(x, y));
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updateNet();
            drawNet();
            
            for (let ball of balls) {
                ball.update();
                checkNetCollision(ball);
            }
            
            // 检查球与球之间的碰撞
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    balls[i].checkCollision(balls[j]);
                }
            }
            
            for (let ball of balls) {
                ball.draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        function toggleMenu() {
            const menu = document.getElementById('menu');
            menu.classList.toggle('collapsed');
        }
        
        // 事件监听
        document.getElementById('netHeight').addEventListener('input', (e) => {
            netHeight = parseFloat(e.target.value);
            document.getElementById('heightValue').textContent = netHeight;
            initNet();
        });
        
        document.getElementById('netLength').addEventListener('input', (e) => {
            netLength = parseFloat(e.target.value);
            document.getElementById('lengthValue').textContent = netLength;
            initNet();
        });
        
        document.getElementById('netStiffness').addEventListener('input', (e) => {
            netStiffness = parseFloat(e.target.value);
            document.getElementById('stiffnessValue').textContent = netStiffness;
        });
        
        document.getElementById('ballCount').addEventListener('input', (e) => {
            ballCount = parseInt(e.target.value);
            document.getElementById('ballCountValue').textContent = ballCount;
            initBalls();
        });
        
        document.getElementById('ballSize').addEventListener('input', (e) => {
            ballRadius = parseInt(e.target.value);
            document.getElementById('ballSizeValue').textContent = ballRadius;
            balls.forEach(ball => ball.radius = ballRadius);
        });
        
        document.getElementById('gravity').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = gravity;
        });
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initNet();
            initBalls();
        });
        
        // 初始化
        initNet();
        initBalls();
        animate();
    </script>
</body>
</html>