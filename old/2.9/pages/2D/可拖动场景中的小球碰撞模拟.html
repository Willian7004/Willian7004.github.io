<!DOCTYPE html>
<!--
写一个2d形式的html程序，在画布内创建多个随机颜色的不重叠的小球，在可折叠菜单设置小球直径和数量。拖动界面（适配鼠标和触屏）时模拟场景向相应方向的移动，在菜单中设置移动距离倍数。模拟小球之间以及小球与画布边缘的弹性碰撞。
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D弹性小球模拟器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #000;
            overflow: hidden;
            user-select: none;
        }

        #canvas {
            border: 1px solid #ccc;
            background-color: #fff;
            cursor: grab;
            display: block;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .menu {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            min-width: 200px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .menu-header {
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .menu-header::after {
            content: '▼';
            transition: transform 0.3s;
        }

        .menu.collapsed .menu-header::after {
            transform: rotate(-90deg);
        }

        .menu.collapsed .menu-content {
            display: none;
        }

        .menu-content {
            transition: max-height 0.3s ease;
            overflow: hidden;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .value-display {
            font-size: 12px;
            color: #666;
            text-align: right;
        }

        button {
            width: 100%;
            padding: 8px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="menu" id="menu">
        <div class="menu-header">控制面板</div>
        <div class="menu-content">
            <div class="control-group">
                <label>小球直径：<span class="value-display" id="diameterValue">30</span>px</label>
                <input type="range" id="diameter" min="20" max="80" value="30">
            </div>
            
            <div class="control-group">
                <label>小球数量：<span class="value-display" id="countValue">30</span></label>
                <input type="range" id="count" min="10" max="100" value="30">
            </div>
            
            <div class="control-group">
                <label>移动距离倍数：<span class="value-display" id="moveMultiplierValue">1.0</span></label>
                <input type="range" id="moveMultiplier" min="0.5" max="10" step="0.1" value="1">
            </div>
            
            <button onclick="resetBalls()">重置小球</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        
        // 设置画布大小
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 菜单折叠功能
        const menuHeader = menu.querySelector('.menu-header');
        menuHeader.addEventListener('click', () => {
            menu.classList.toggle('collapsed');
        });

        // 小球类
        class Ball {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.stroke();
            }
        }

        // 全局变量
        let balls = [];
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let offsetX = 0;
        let offsetY = 0;
        let moveMultiplier = 1;

        // 生成随机颜色
        function getRandomColor() {
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', 
                '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // 检查是否重叠
        function isOverlapping(x, y, radius, existingBalls) {
            for (let ball of existingBalls) {
                const dx = x - ball.x;
                const dy = y - ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < radius + ball.radius + 5) {
                    return true;
                }
            }
            return false;
        }

        // 初始化小球
        function initBalls() {
            balls = [];
            const diameter = parseInt(document.getElementById('diameter').value);
            const count = parseInt(document.getElementById('count').value);
            const radius = diameter / 2;
            
            for (let i = 0; i < count; i++) {
                let x, y;
                let attempts = 0;
                do {
                    x = Math.random() * (canvas.width - diameter) + radius;
                    y = Math.random() * (canvas.height - diameter) + radius;
                    attempts++;
                } while (isOverlapping(x, y, radius, balls) && attempts < 100);
                
                if (attempts < 100) {
                    const color = getRandomColor();
                    balls.push(new Ball(x, y, radius, color));
                }
            }
        }

        // 重置小球
        function resetBalls() {
            initBalls();
        }

        // 碰撞检测
        function checkCollisions() {
            // 小球之间的碰撞
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const dx = balls[j].x - balls[i].x;
                    const dy = balls[j].y - balls[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = balls[i].radius + balls[j].radius;
                    
                    if (distance < minDistance) {
                        // 计算碰撞角度
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // 旋转速度
                        const vx1 = balls[i].vx * cos + balls[i].vy * sin;
                        const vy1 = balls[i].vy * cos - balls[i].vx * sin;
                        const vx2 = balls[j].vx * cos + balls[j].vy * sin;
                        const vy2 = balls[j].vy * cos - balls[j].vx * sin;
                        
                        // 碰撞后的速度
                        const finalVx1 = vx2;
                        const finalVx2 = vx1;
                        
                        // 旋转回原坐标系
                        balls[i].vx = finalVx1 * cos - vy1 * sin;
                        balls[i].vy = vy1 * cos + finalVx1 * sin;
                        balls[j].vx = finalVx2 * cos - vy2 * sin;
                        balls[j].vy = vy2 * cos + finalVx2 * sin;
                        
                        // 分离重叠的小球
                        const overlap = minDistance - distance;
                        const separationX = overlap * cos / 2;
                        const separationY = overlap * sin / 2;
                        balls[i].x -= separationX;
                        balls[i].y -= separationY;
                        balls[j].x += separationX;
                        balls[j].y += separationY;
                    }
                }
            }
            
            // 与画布边缘的碰撞
            balls.forEach(ball => {
                if (ball.x - ball.radius < -offsetX || ball.x + ball.radius > canvas.width - offsetX) {
                    ball.vx = -ball.vx;
                    ball.x = Math.max(ball.radius - offsetX, Math.min(ball.x, canvas.width - ball.radius - offsetX));
                }
                if (ball.y - ball.radius < -offsetY || ball.y + ball.radius > canvas.height - offsetY) {
                    ball.vy = -ball.vy;
                    ball.y = Math.max(ball.radius - offsetY, Math.min(ball.y, canvas.height - ball.radius - offsetY));
                }
            });
        }

        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            
            checkCollisions();
            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });
            
            ctx.restore();
            requestAnimationFrame(animate);
        }

        // 鼠标事件
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = (e.clientX - lastX) * moveMultiplier;
                const deltaY = (e.clientY - lastY) * moveMultiplier;
                offsetX += deltaX;
                offsetY += deltaY;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // 触屏事件
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            isDragging = true;
            lastX = touch.clientX;
            lastY = touch.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) {
                const touch = e.touches[0];
                const deltaX = (touch.clientX - lastX) * moveMultiplier;
                const deltaY = (touch.clientY - lastY) * moveMultiplier;
                offsetX += deltaX;
                offsetY += deltaY;
                lastX = touch.clientX;
                lastY = touch.clientY;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
        });

        // 更新显示值
        document.getElementById('diameter').addEventListener('input', (e) => {
            document.getElementById('diameterValue').textContent = e.target.value;
        });

        document.getElementById('count').addEventListener('input', (e) => {
            document.getElementById('countValue').textContent = e.target.value;
        });

        document.getElementById('moveMultiplier').addEventListener('input', (e) => {
            moveMultiplier = parseFloat(e.target.value);
            document.getElementById('moveMultiplierValue').textContent = e.target.value;
        });

        // 初始化
        initBalls();
        animate();
    </script>
</body>
</html>